"use strict";(self.webpackChunksemana_9=self.webpackChunksemana_9||[]).push([[1921],{3982:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"memory/detectar-fugas","title":"Detecci\xf3n de Fugas de Memoria","description":"Las fugas de memoria ocurren cuando objetos que ya no son necesarios siguen siendo referenciados, impidiendo que el recolector de basura los elimine. Esto puede causar un incremento constante en el uso de memoria, degradando el rendimiento de la aplicaci\xf3n o incluso provocando fallos.","source":"@site/docs/memory/detectar-fugas.md","sourceDirName":"memory","slug":"/memory/detectar-fugas","permalink":"/memory/detectar-fugas","draft":false,"unlisted":false,"editUrl":"https://github.com/HaroldRumiche/semana-9/tree/main/docs/memory/detectar-fugas.md","tags":[],"version":"current","lastUpdatedBy":"HaroldRumiche","lastUpdatedAt":1745307533000,"sidebarPosition":8,"frontMatter":{"id":"detectar-fugas","sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Recolecci\xf3n de Basura","permalink":"/memory/garbage-collection"},"next":{"title":"Consejos de Optimizaci\xf3n de Memoria","permalink":"/memory/consejos-optimizacion"}}');var i=a(4848),r=a(8453);a(8335),a(6562);const o={id:"detectar-fugas",sidebar_position:8},c="Detecci\xf3n de Fugas de Memoria",d={},l=[{value:"\xbfQu\xe9 es una fuga de memoria?",id:"qu\xe9-es-una-fuga-de-memoria",level:2},{value:"Se\xf1ales de fugas de memoria",id:"se\xf1ales-de-fugas-de-memoria",level:2},{value:"M\xe9todos de detecci\xf3n con DevTools",id:"m\xe9todos-de-detecci\xf3n-con-devtools",level:2},{value:"1. Grabaci\xf3n de l\xednea temporal de memoria",id:"1-grabaci\xf3n-de-l\xednea-temporal-de-memoria",level:3},{value:"2. M\xfaltiples instant\xe1neas de heap",id:"2-m\xfaltiples-instant\xe1neas-de-heap",level:3},{value:"3. Detecci\xf3n de objetos retenidos",id:"3-detecci\xf3n-de-objetos-retenidos",level:3},{value:"Causas comunes de fugas de memoria",id:"causas-comunes-de-fugas-de-memoria",level:2},{value:"An\xe1lisis de patrones espec\xedficos",id:"an\xe1lisis-de-patrones-espec\xedficos",level:2},{value:"Detecci\xf3n de listeners hu\xe9rfanos",id:"detecci\xf3n-de-listeners-hu\xe9rfanos",level:3},{value:"Identificaci\xf3n de referencias a elementos eliminados",id:"identificaci\xf3n-de-referencias-a-elementos-eliminados",level:3},{value:"Estrategias de confirmaci\xf3n",id:"estrategias-de-confirmaci\xf3n",level:2},{value:"Herramientas avanzadas",id:"herramientas-avanzadas",level:2}];function t(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"detecci\xf3n-de-fugas-de-memoria",children:"Detecci\xf3n de Fugas de Memoria"})}),"\n",(0,i.jsx)(n.p,{children:"Las fugas de memoria ocurren cuando objetos que ya no son necesarios siguen siendo referenciados, impidiendo que el recolector de basura los elimine. Esto puede causar un incremento constante en el uso de memoria, degradando el rendimiento de la aplicaci\xf3n o incluso provocando fallos."}),"\n",(0,i.jsx)(n.h2,{id:"qu\xe9-es-una-fuga-de-memoria",children:"\xbfQu\xe9 es una fuga de memoria?"}),"\n",(0,i.jsx)(n.p,{children:"Una fuga de memoria en JavaScript ocurre cuando:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Un objeto que ya no se necesita sigue siendo referenciado por el c\xf3digo"}),"\n",(0,i.jsx)(n.li,{children:"El recolector de basura no puede liberar este objeto"}),"\n",(0,i.jsx)(n.li,{children:"La memoria no se libera y se acumula con el tiempo"}),"\n",(0,i.jsx)(n.li,{children:"Eventualmente, esto puede agotar los recursos del navegador"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"A diferencia de errores de sintaxis, las fugas de memoria son dif\xedciles de detectar sin las herramientas adecuadas."}),"\n",(0,i.jsx)(n.h2,{id:"se\xf1ales-de-fugas-de-memoria",children:"Se\xf1ales de fugas de memoria"}),"\n",(0,i.jsx)(n.p,{children:"Las fugas de memoria suelen manifestarse de varias formas:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Aumento constante del uso de memoria a lo largo del tiempo"}),"\n",(0,i.jsx)(n.li,{children:"La aplicaci\xf3n se vuelve m\xe1s lenta progresivamente"}),"\n",(0,i.jsx)(n.li,{children:'Errores de "out of memory" en sesiones largas'}),"\n",(0,i.jsx)(n.li,{children:"El rendimiento se degrada despu\xe9s de ciertos ciclos de interacci\xf3n"}),"\n",(0,i.jsx)(n.li,{children:"La pesta\xf1a del navegador consume cada vez m\xe1s recursos"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"m\xe9todos-de-detecci\xf3n-con-devtools",children:"M\xe9todos de detecci\xf3n con DevTools"}),"\n",(0,i.jsx)(n.p,{children:"Chrome DevTools ofrece varias t\xe9cnicas para identificar fugas de memoria:"}),"\n",(0,i.jsx)(n.h3,{id:"1-grabaci\xf3n-de-l\xednea-temporal-de-memoria",children:"1. Grabaci\xf3n de l\xednea temporal de memoria"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Abre el panel Memory"}),"\n",(0,i.jsx)(n.li,{children:'Selecciona "Allocation instrumentation on timeline"'}),"\n",(0,i.jsx)(n.li,{children:'Haz clic en "Start"'}),"\n",(0,i.jsx)(n.li,{children:"Realiza ciclos de la acci\xf3n sospechosa (ej: navegar a una p\xe1gina y volver)"}),"\n",(0,i.jsx)(n.li,{children:"Det\xe9n la grabaci\xf3n y analiza si hay incrementos constantes en la memoria"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-m\xfaltiples-instant\xe1neas-de-heap",children:"2. M\xfaltiples instant\xe1neas de heap"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Toma una instant\xe1nea inicial de memoria"}),"\n",(0,i.jsx)(n.li,{children:"Realiza la acci\xf3n sospechosa varias veces"}),"\n",(0,i.jsx)(n.li,{children:"Fuerza la recolecci\xf3n de basura (icono de papelera)"}),"\n",(0,i.jsx)(n.li,{children:"Toma otra instant\xe1nea"}),"\n",(0,i.jsx)(n.li,{children:'Compara las instant\xe1neas usando la opci\xf3n "Comparison"'}),"\n",(0,i.jsx)(n.li,{children:"Busca objetos que aumentan consistentemente en cada instant\xe1nea"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-detecci\xf3n-de-objetos-retenidos",children:"3. Detecci\xf3n de objetos retenidos"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Toma una instant\xe1nea de memoria"}),"\n",(0,i.jsx)(n.li,{children:'Ordena por "Retained Size" para ver los objetos que retienen m\xe1s memoria'}),"\n",(0,i.jsx)(n.li,{children:"Expande los objetos para ver sus cadenas de retenci\xf3n"}),"\n",(0,i.jsx)(n.li,{children:"Identifica referencias inesperadas o circulares"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"causas-comunes-de-fugas-de-memoria",children:"Causas comunes de fugas de memoria"}),"\n",(0,i.jsx)(n.p,{children:"Las fugas de memoria en JavaScript suelen ocurrir por:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Event listeners no eliminados"}),": Agregar listeners sin removerlos cuando ya no son necesarios"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Referencias circulares"}),": Objetos que se referencian mutuamente de manera circular"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Closures no intencionales"}),": Funciones que mantienen referencias a objetos del contexto externo"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Elementos DOM desconectados"}),": Mantener referencias a elementos eliminados del DOM"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timers y callbacks persistentes"}),": ",(0,i.jsx)(n.code,{children:"setInterval"})," o promesas no canceladas"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cach\xe9s sin l\xedmites"}),": Almacenar datos sin mecanismos para liberarlos"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"an\xe1lisis-de-patrones-espec\xedficos",children:"An\xe1lisis de patrones espec\xedficos"}),"\n",(0,i.jsx)(n.h3,{id:"detecci\xf3n-de-listeners-hu\xe9rfanos",children:"Detecci\xf3n de listeners hu\xe9rfanos"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:'En la instant\xe1nea de memoria, busca "(event listeners)"'}),"\n",(0,i.jsx)(n.li,{children:"Examina los nodos que retienen estos listeners"}),"\n",(0,i.jsx)(n.li,{children:"Verifica si corresponden a elementos que deber\xedan haberse eliminado"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"identificaci\xf3n-de-referencias-a-elementos-eliminados",children:"Identificaci\xf3n de referencias a elementos eliminados"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:'En las herramientas de memoria, busca "Detached"'}),"\n",(0,i.jsx)(n.li,{children:"Estos son elementos DOM que est\xe1n en memoria pero no en el documento"}),"\n",(0,i.jsx)(n.li,{children:"Examina qu\xe9 est\xe1 reteniendo estos elementos"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"estrategias-de-confirmaci\xf3n",children:"Estrategias de confirmaci\xf3n"}),"\n",(0,i.jsx)(n.p,{children:"Para confirmar una fuga de memoria:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Implementa un caso de prueba que a\xedsle la funcionalidad sospechosa"}),"\n",(0,i.jsx)(n.li,{children:"Ejecuta esta acci\xf3n en un ciclo repetitivo"}),"\n",(0,i.jsx)(n.li,{children:"Observa si la memoria crece constantemente sin estabilizarse"}),"\n",(0,i.jsx)(n.li,{children:"Utiliza puntos de depuraci\xf3n condicionales para identificar cu\xe1ndo se crean objetos problem\xe1ticos"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"herramientas-avanzadas",children:"Herramientas avanzadas"}),"\n",(0,i.jsx)(n.p,{children:"Para casos m\xe1s complejos:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Utiliza la API ",(0,i.jsx)(n.code,{children:"performance.memory"})," para monitoreo program\xe1tico"]}),"\n",(0,i.jsxs)(n.li,{children:["Implementa puntos de control de memoria con ",(0,i.jsx)(n.code,{children:"performance.mark()"})]}),"\n",(0,i.jsx)(n.li,{children:"Considera herramientas como el Heap Profiler de Chrome para an\xe1lisis profundo"}),"\n",(0,i.jsx)(n.li,{children:"Utiliza la pesta\xf1a Performance para correlacionar el uso de memoria con la actividad JavaScript espec\xedfica"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"En la siguiente secci\xf3n, exploraremos consejos pr\xe1cticos para optimizar el uso de memoria y prevenir fugas."})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(t,{...e})}):t(e)}},6562:(e,n,a)=>{a.d(n,{A:()=>i});a(6540);var s=a(4848);const i=function(e){return(0,s.jsx)("docs-cards",{class:e.className,children:e.children})}},8335:(e,n,a)=>{a.d(n,{A:()=>d});a(6540);var s=a(4164),i=a(6289),r=a(9030);const o="card_HCHm";var c=a(4848);const d=function(e){const n=void 0===e.href,a=void 0!==e.href&&/^http/.test(e.href),d="undefined"===e.header?null:(0,c.jsx)("header",{className:"Card-header",children:e.header}),l=e.hoverIcon||e.icon,t=(0,c.jsxs)(c.Fragment,{children:[e.img&&(0,c.jsx)("img",{src:(0,r.Ay)(e.img),className:"Card-image"}),(0,c.jsxs)("div",{className:"Card-container",children:[(e.icon||l)&&(0,c.jsxs)("div",{className:"Card-icon-row",children:[e.icon&&(0,c.jsx)("img",{src:(0,r.Ay)(e.icon),className:"Card-icon Card-icon-default"}),l&&(0,c.jsx)("img",{src:(0,r.Ay)(l),className:"Card-icon Card-icon-hover"})]}),e.ionicon&&(0,c.jsx)("ion-icon",{name:e.ionicon,className:"Card-ionicon"}),e.iconset&&(0,c.jsx)("div",{className:"Card-iconset__container",children:e.iconset.split(",").map(((n,a)=>(0,c.jsx)("img",{src:(0,r.Ay)(n),className:"Card-icon "+(a===e.activeIndex?"Card-icon-active":""),"data-index":a},a)))}),e.header&&d,(0,c.jsx)("div",{className:"Card-content",children:e.children})]})]}),m=(0,s.A)({"Card-with-image":void 0!==e.img,"Card-without-image":void 0===e.img,"Card-size-lg":"lg"===e.size,[e.className]:e.className});return n?(0,c.jsx)("docs-card",{class:m,children:(0,c.jsx)("div",{className:(0,s.A)(o,"docs-card"),children:t})}):a?(0,c.jsx)("docs-card",{class:m,children:(0,c.jsx)("a",{className:(0,s.A)(o,"docs-card"),href:e.href,target:"_blank",children:t})}):(0,c.jsx)("docs-card",{class:m,children:(0,c.jsx)(i.A,{to:e.href,className:(0,s.A)(o,"docs-card"),children:t})})}},8453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>c});var s=a(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);